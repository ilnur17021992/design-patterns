# Шаблоны проектирования

## Основные (англ. fundamental) 

Это низкоуровневые шаблоны, которые определяют базовые принципы и техники программирования.

* Интерфейс - определяет контракт между разными объектами или классами.

* Контейнер свойств - позволяет добавлять дополнительные свойства для класса в контейнер (внутри класса), вместо расширения класса новыми свойствами.
Хранить свойства можно не только в массиве, но и в базе данных или в json файлах.

* Делегирование - объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. Простыми словами класс А делегирует поведение классу Б.

* Канал событий - используется для создания канала связи и коммуникации через него посредством событий. Этот канал обеспечивает возможность разным издателям публиковать события и подписчикам, подписываясь на них, получать уведомления.

## Порождающие (англ. creational)

Это шаблоны, которые отвечают за создание и инициализацию объектов.

* Абстрактная фабрика (инструментарий) — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов (связь на интерфейсах).

* Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

* Статическая фабрика - главное отличие от абстрактной фабрики в том, что Статическая фабрика использует только один статический метод, чтобы создать все допустимые типы объектов. Этот метод, обычно называется 'factory' или 'build'.

* Простая фабрика - то же самое что и статическая фабрика, но вместо статического метода используется обычный.

* Одиночка - шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру. При первом обращении - объект создается, а при последующий отдается ранее созданный объект.

* Пулл одиночек - то же самое что и одиночка, но позволяет создавать экземпляры одного и того же класса с разными ключами (идентификаторами). Допустим, есть класс ддя обращения к базе данных, можно создать два объекта этого класса, но с разными ключами, например: один для обращения к MySQL, а другой для PostgreSQL. Получается будет два объекта одного класса, но с разными настройками.

* Строитель - порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель дает возможность использовать один и тот же код "строительства" для получения разных представлений объектов.

## Структурные (англ. structural)

Это шаблоны, которые определяют отношения и композицию между объектами или классами.

* Декоратор (Decorator) - шаблон проектирования предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности. Это может быть полезно, когда требуется добавить к объекту дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта.

* DTO (Data Transfer Object) - это объект который переносит данные между системами
(веб-сервисы, подсистемы или процессы одного приложения)

    Первичная цель ОТО заключалась в передаче данных при дорогостоящих
    удаленных вызовах. Вместо нескольких вызовов и передачи нескольких
    объектов делается один вызов и передается один собирательный объект.

    Так же решаются проблемы:
    - Ошибки при сериализации передаваемых объектов
    - Сложная многоуровневая структура объектов
    - Ненужные (излишние) для передачи данные

    Объект DTO не должен содержать никакого поведения
    (никакой бизнес-логики), кроне хранения, извлечения, сериализации и десериализации собственных данных.


## Поведенческие (англ. behavioral)

Это шаблоны, которые определяют алгоритмы и способы взаимодействия между объектами или классами.

* Стратегия - это поведенческий паттерн, который выносит набор алгоритмов в подклассы и делает их взаимозаменяемыми.
